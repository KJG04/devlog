---
title: '[번역] 모든 것을 메모하는 이유'
tags:
  - react
  - memo
  - useMemo
  - useCallback
  - optimize
keyword: react, memo, useMemo, useCallback, re-rendering, optimize, 리액트, memo, 최적화, 리렌더링, 성능, performance
series: react optimize
published: true
date: 2023-04-01T21:50:08+09:00
description: 코인베이스의 우리 팀에서는 모든 사람에게 memo, useMemo, useCallback이라는 React 성능 삼위일체를 항상 사용하도록 요청합니다. 어떤 이유에서인지 이것은 논란의 여지가 있습니다. 아마도 트위터와 관련이 있는 것 같습니다. 이 글에서는 왜 그렇게 하는지 설명합니다.
thumbnail: /img/thumbnail-2023-04-01.webp
---

Original post: [Why We Memo All the Things](https://attardi.org/why-we-memo-all-the-things/)

Author: [Stefano J. Attardi](https://attardi.org/)

의역, 오역이 있을 수 있습니다.

---

[CoinBase](https://www.coinbase.com/)의 우리 팀에서는 모든 사람에게 `memo`, `useMemo`, `useCallback`이라는 `React` 성능 삼위일체를 항상 사용하도록 요청합니다. 어떤 이유에서인지 이것은 논란의 여지가 있습니다. 아마도 트위터와 관련이 있는 것 같습니다. 이 글에서는 왜 그렇게 하는지 설명합니다.

## 모든 컴포넌트에 `React.memo`를 사용하는 이유

우리 모두가 동의할 수 있는 것부터 시작하겠습니다. 대부분의 앱에서 일부 컴포넌트는 `React.memo`로 감싸는 것이 이득일 수 있습니다. 렌더링 비용이 많이 들거나 렌더링 빈도가 훨씬 더 높은 컴포넌트의 자식이기 때문일 수도 있습니다. 아니면 둘 다일 수도 있습니다.

<br />

따라서 `memo`를 전혀 사용하지 않는 것은 선택사항이 아닙니다. 두 가지 옵션이 남습니다:

- `memo`를 일부만 사용
- 항상 `memo` 사용

첫 번째 옵션이 가장 매력적으로 들리지 않나요? `React.memo`의 이점을 누릴 수 있는 시기를 파악하고 그때만 사용하면 됩니다. 하지만 거기까지 가기 전에 우리는 대규모 팀에서 일한다는 사실을 상기해야 합니다. 교육, 코드 리뷰, 프로파일링을 아무리 부지런히 해도 항상 100% 제대로 할 수는 없습니다. 따라서 우리는 스스로에게 물어봐야 합니다:

> 틀렸을 때 어떤 대가를 치를까요?

`memo`할 필요가 없는 컴포넌트를 `memo`하면 해당 컴포넌트의 소품과 각 렌더링 가능성에 대해 얕은 수준의 동등성 검사만 하게 됩니다.

<br />

만약 `memo`해야 할 컴포넌트를 `memo`하지 않는다면, `React`는:

1. 렌더링 함수 실행
2. 모든 콜백을 새로 할당
3. 모든 `useMemo` 함수를 새로 할당합니다.
4. 새로운 `JSX` 요소 다량 할당하기
5. 모든 자식에 대해 1~4를 재귀적으로 반복하기
6. `React reconciler`가 이전 트리와 새 트리를 비교하도록 하기

`React` 앱을 프로파일링해 본 적이 있다면(프로덕션 모드에서도) 렌더링하는 모든 컴포넌트에 무시할 수 없는 성능 영향이 있다는 것을 알고 계실 것입니다. 반면에 `memo`의 `props` 비교는 프로파일에 거의 나타나지 않습니다.

<br />

컴포넌트를 낭비적으로 다시 렌더링하는 것은 `props`가 변경되었는지 테스트하는 것보다 비용이 더 많이 듭니다. 따라서 불필요한 리렌더링을 피하는 편이 낫습니다. 인간은 오류를 범할 수 있기 때문에 이를 방지하는 유일한 방법은 기본적으로 모든 것을 `memo`하는 것입니다.

## 정상 기본값

게다가 `memo`를 사용할 때와 사용하지 않을 때를 결정할 책임을 모든 엔지니어에게 맡기면 불필요한 부담을 줄 수 있습니다. 모든 사람이 장단점을 잘 알고 있어야 할까요? 결정을 내리기 위해 각 구성 요소를 프로파일링해야 하나요? 이를 올바르게 수행하기 위해 추가적인 정신적 노력과 시간을 투자하는 데 드는 비용은 얼마인가요? 그만한 가치가 있을까요? 정상 기본값을 제공하고 필요할 때만 분산하는 것은 어떨까요?

## `React.memo`의 CPU 비용

하지만 대부분의 컴포넌트가 리렌더링 비용이 저렴하다면 어떨까요? 이 모든 불필요한 `memo`의 비용이 낭비되는 값비싼 리렌더링의 비용보다 더 많이 들지 않을까요?

<br />

제 경험상 대답은 '아니오'입니다. 프로필에 `memo` 자체가 표시되는 경우는 본 적이 없지만, 고가의 렌더링에 엄청난 CPU 시간이 소요되는 경우는 꽤 흔하게 볼 수 있습니다. 뭔가 다른 것이 보인다면 너무 많은 컴포넌트가 마운트되어 있는 등 더 큰 문제가 있을 수 있습니다.

<Blockquote size="$sm">
  `memo`를 통해 측정 가능한 성능 향상을 가져온 유효한 사용 사례가 있다면 저에게
  연락해 주세요. 새로운 정보를 바탕으로 이 게시물을 업데이트해 드리겠습니다!
</Blockquote>

## `React.memo`의 메모리 비용

다른 `memo`와 마찬가지로 나중에 다시 필요할 때를 대비해 이전 값을 보관해야 하기 때문에 `React.memo`에 메모리 비용이 든다는 `memo` 밈(meme)이 돌아다니고 있습니다. 말이 되나요? 불행히도, 그것은 옳지 않습니다. `React`가 작동하는 방식 때문에, 이전 렌더링의 결과는 후속 렌더링과 비교하기 위해 어쨌든 보관해야 합니다. 이것이 `React`의 조정 알고리즘의 기초입니다. 이 알고리즘 없이는 작동할 수 없습니다.

<br />

단순히 제 말만 믿지 마세요. 다음은 [트위터에서 Christopher Chedeau가 Dan Abramov에게 보낸 답변](https://twitter.com/Vjeux/status/1083902075946205189)입니다:

<Blockquote color="$blue600" borderColor="$blue400">
  좋은 비유라고 생각하지 않습니다. 모든 함수에서 `memoize()`를 수행하면 모든
  호출에 대한 입력/출력 상태를 저장해야 하므로 끔찍한 일이 될 것입니다. React의
  경우 이미 모든 함수에 대해 이 작업을 수행하므로 "무료"입니다.
</Blockquote>

<Blockquote size="$xs">
  잘 모르시는 분들을 위해 소개하자면, Christopher Chedeau는 2012년부터, 즉
  초창기부터 Facebook의 `React` 코어 팀에서 일해 왔습니다. 그는 `React Native`,
  `Prettier`, `CSS-in-JS`, `Excalidraw`, `Yoga`를 만들었습니다.
</Blockquote>

## 조기 최적화가 아닌가요?

조기 최적화는 어떤 코드를 더 빠르게 만들어야 하는지 알기도 전에 성능에 맞춰 코드를 최적화하는 데 시간을 소비하는 것입니다. 엔지니어에게 모든 컴포넌트에 대해 메모-비메모 선택을 요구함으로써, `memo` 호출로 인한 잠재적인 성능 비용을 우려하여 성능에 대해 더 많은 시간을 할애하도록 강요하고 있습니다. 제 생각에는 이는 조기 최적화입니다. 그 반대는 아닙니다.

## 모든 콜백을 `React.useCallback`하는 이유

`React.memo`에 대해 같은 생각을 하고 계신가요? 그렇다면 이 문제는 쉬울 것입니다. 대부분의 경우 콜백은 다른 컴포넌트에 `props`으로 전달됩니다. 만약 `useCallback`으로 감싸지 않으면 `memo`가 깨지게 됩니다. 아주 간단합니다. 콜백을 `useCallback`으로 감싸면 `memo`가 작동합니다.

<br />

원시 컴포넌트(primitive components)로 전달되는 콜백은 어떨까요? 이런 경우 `useCallback`은 쓸모가 없지 않나요? 그렇습니다. 하지만. 다음 인턴이 여러분의 원시 컴포넌트를 다른 컴포넌트로 래핑할 때, 그 인턴이 다시 돌아가서 전달된 콜백을 모두 변경하여 `useCallback`으로 래핑하는 것을 알 수 있을까요? 아마 아닐 겁니다.

<br />

또한, 정상 기본값으로 엔지니어에게 추가적인 부담을 주지 않아야 한다는 위의 논거는 여전히 적용됩니다. `useCallback`의 CPU 및 메모리 비용은 무시할 수 있을 정도로 적습니다. 예, 콜백은 어떤 경우에도 메모리에 남아 있어야 합니다. 결국 호출해야 할 수도 있으니까요!

<br />

간단히 말해서 모든 함수를 `useCallback`으로 감싸면 됩니다.

## 모든 `props`와 의존성 배열에 `useMemo`를 사용하는 이유

새로운 객체나 배열을 생성할 때도 마찬가지입니다. `useMemo`로 감싸지 않으면 해당 값을 `props`로 받는 모든 컴포넌트가 손상될 것입니다.

<br />

의존성 배열에 있는, 렌더링할 때마다 다시 생성되는 모든 데이터 구조는 `useCallback` 및 `useMemo`의 다운스트림을 중단시킬 수도 있습니다. 이렇게 계속 변하는 값은 `useCallback` 및 파생된 값에서 참조되므로, 마스크를 착용하는 사람이 절반밖에 되지 않는 마을에서 코로나 바이러스가 퍼지는 것처럼 파손이 확산됩니다. 기본적으로 `memo`가 되어 있지 않은 경우, 성능 문제가 발생했을 때 디버깅하려면 의존성 사슬을 거슬러 올라가 모든 단계에서 `memo`를 추가해야 하므로 긴 두더지 게임이 될 것입니다.

## 제발 아이들 좀 생각해주실래요?

많은 사람들이 모르는 사실이지만, `children`은 `memo`를 방해하는 교활한 `props`입니다. `JSX`는 렌더링할 때마다 새로운 데이터 구조를 생성합니다. 컴포넌트가 `JSX`를 다시 렌더링하여 다른 컴포넌트에 전달할 때마다 자식 컴포넌트의 `memo`가 깨지게 됩니다.

<br />

이 문제를 어떻게 처리할까요? 렌더링 중에 생성되는 다른 모든 복잡한 데이터 구조를 처리하는 것과 같은 방법으로 `useMemo`를 사용합니다.

<br />

저도 여러분이 무슨 생각을 하는지 압니다. 아무도 자식 컴포넌트를 `useMemo`로 감싸지 않는다는 것을요, 그리고 맞습니다. 저희도 코드베이스에서 이렇게 하는 경우가 많지 않다는 것을 인정합니다. 관용적인 React가 아니기 때문에 모든 곳에서 이 작업을 수행하는 것은 너무 무리한 요구일 수 있습니다. 그래서 우리는 이 타협을 감수하며 살고 있습니다. 즉, 경계를 늦추지 않고 앱에 성능 문제가 있는지 지속적으로 모니터링해야 합니다. 좋은 소식은 문제를 발견했을 때, `children props`에 `useMemo`를 감싸는 것이 처음부터 아무런 최적화 없이 시작한 거미줄 같이 복잡한 hook와 컴포넌트에 온갖 종류의 최적화를 추가하는 것보다 훨씬 더 간단하다는 것입니다.

## 결론

모든 곳에서 `memo`와 그 사촌들을 사용하는 것은 정상 기본값입니다. 마치 코로나 바이러스 팬데믹 기간 동안 마스크 착용을 의무화하는 것과 같습니다. 물론 모든 사람이 매일 검사를 받고 전염성이 강한 사람에게만 마스크 착용을 요청할 수도 있습니다. 하지만 모든 사람에게 기본적으로 마스크를 착용하도록 요청하는 것이 훨씬 저렴하고 간단하며 궁극적으로 더 효과적입니다.
